<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE rfc SYSTEM "rfc2629-xhtml.ent">
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="4"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<rfc category="std" ipr="trust200902"
    docName="draft-ietf-netmod-yang-schema-comparison-03" updates="7950"
    submissionType="IETF" consensus="true">
  <front>
    <title abbrev="YANG Schema Comparison">YANG Schema Comparison</title>
    <author initials="P." role="editor" surname="Andersson"
        fullname="Per Andersson">
      <organization abbrev="Ionio Systems">
        Ionio Systems
      </organization>
      <address>
        <email>per.ietf@ionio.se</email>
      </address>
    </author>
    <author initials="R." surname="Wilton" fullname="Robert Wilton">
      <organization abbrev="Cisco Systems, Inc.">
        Cisco Systems, Inc.
      </organization>
      <address>
        <email>rwilton@cisco.com</email>
      </address>
    </author>
    <author initials="M." surname="Vaško" fullname="Michal Vaško">
      <organization abbrev="CESNET">
        CESNET
      </organization>
      <address>
        <email>mvasko@cesnet.cz</email>
      </address>
    </author>
    <date/>
    <abstract>
        <t>This document specifies an algorithm for comparing two revisions of a
            YANG schema to determine the scope of changes, and a list of
            changes, between the revisions. The output of the algorithm can be
            used to help select an appropriate revision-label or YANG semantic
            version number for a new revision. Included is also a YANG module
            describing the output of this algorithm.</t>
    </abstract>
  </front>
  <middle>
    <section anchor="key-issues" numbered="true" toc="default">
      <name>Key Issues</name>
      <t>{ This section is only to present the current ongoing work, not part of
      the final draft. }</t>
      <t>The contributors have identified several key issues that need
      attention. This section presents selected key issues which have been
      discussed together with suggestions for proposed solution or
      requirements.</t>
      <section>
        <name>On-wire vs Schema analysis</name>
        <t>Should one algorithm be used or two? The consesus reached was to
            define two separate algorithms, one for on-wire format and one for
            schema.</t>
        <t>Schema: any changes that affect the YANG schema in an NBC manner
            according to the full rules of
            <xref target="I-D.ietf-netmod-yang-module-versioning" format="default"/>.
            This may be important for clients that, for example, automatically
            generate code using the YANG and where the change of a typedef name
            or a choice name could be significant. Also important for other
            modules that may augment or deviate the schema being compared.</t>
        <t>Changes to the module that aren't semantic should raise that there
        has been editorial changes</t>
        <t>
            Ordering in the schema, RFC 7950 doesn't allow reordering; thus an
            NBC change.
        </t>
        <t>Open Questions:</t>
        <t>Groupings / uses</t>
        <t>typedefs, namespaces, choice names, prefixes, module metadata.
        <ul><li>typedef renaming (on-wire, same base type etc)</li></ul>
        </t>
        <ul>
            <li>Should all editorial (text) diffs be reported?</li>
            <li>What about editorial changes that might change semantics, e.g.
            a description of a leaf?</li>
            <li>Metadata arguments which relies on the formatted input text.
                E.g description, contact (etc), extension (how does the user
                want to tune verbosity level for editorial changes: whitespace, spelling, editorial, potentially-nbc?</li>
            <li>XPath, must, when: don't normalize XPath expressions</li>
            <li>presence statements</li>
        </ul>
      </section>
      <section>
        <name>Comparison on module or full schema (YANG artifact, arbitrary blob.
            Questions</name>
          <ul>
              <li>features</li>
              <li>packages vs directories vs libraries vs artifact</li>
              <li>package specific comparison, package metadata or only looking
                  at the modules</li>
              <li>import only or implemented module</li>
          </ul>
        <t>
          Filter out comparison for a specific subrtree, path etc. Use case
          for on-wire e.g. yang subscriptions, did the model change fro what is
          subscribed on?
      </t>
      </section>
    </section>
    <section anchor="open-issues">
      <name>Open Issues</name>
      <t>{ This section is only to present the current ongoing work, not part of
      the final draft. }</t>
      <t>The following issues have not ben discussed in any wider extent yet.</t>
      <section>
          <name>Override/per-node tags</name>
      </section>
      <section>
          <name>Separate rules for config vs state</name>
      </section>
      <section>
          <name>Tool/report verbosity</name>
            <ul>
              <li>where to report changes (module, grouping, typedef, uses)</li>
              <li>output level (conceptual level or exact strings)</li>
              <li>granularity: error/warning/info level per reported change
                  category</li>
            </ul>
      </section>
      <section>
          <name>sub-modules</name>
      </section>
      <section>
          <name>Write algorithm in pseudo code or just describe the rules/goals
              in text?</name>
      </section>
      <section>
          <name>Categories in the report: bc, nbc, potentially-nbc, editorial.
          Allow filtering in the draft without defining it?</name>
          <t>One option can be to have a tool option that presents the reason
            behind the decision, e.g. --details could be used to explain to the
            user why a certain change was marked as nbc.</t>
          <t>Another option is to present reasoning and analysis in deeper
            levels of verbosity; e.g. one extra level of verbosity, -v, could
            present the reason for categorizing a change nbc, and an additional
            extra level of verbosity, e.g. -vv, could also present the detailed
            analysis the tool made to categorize the change.</t>
      </section>
      <section>
          <name>Only for YANG 1.1?</name>
      </section>
    </section>
    <section anchor="intro" numbered="true" toc="default">
      <name>Introduction</name>
        <t>
            This document defines the algorithm for comparing two revisions of a
            YANG schema. There are two kinds of YANG schemas: on-the-wire or
            compiled schema and text or parsed schema.
        </t>
        <t>
            The compiled schema is what tools use when working with any kinds of
            YANG data. Generally, in all the YANG modules, all the schema nodes
            need to be fully resolved and have their final form. For example,
            every "uses" statement is replaced with the nodes from the
            corresponding "grouping", every type referencing a "typedef" is
            replaced with the type of the "typedef" and so on. On the other
            hand, the parsed schema is comprised of all the YANG modules
            together as they are. That means no statements are resolved and they
            remain in exactly the same text form as present in the YANG modules.
        </t>
        <t>
            For determining whether a new revision of a YANG 1.1 module is or is
            not backwards-compatible based on all the rules
            in
            <xref target="RFC7950" format="default"/>
            and <xref target="I-D.ietf-netmod-yang-module-versioning" format="default"/>
            ,
            both of these schemas would be required. Similarly for YANG 1.0,
            the rules in
            <xref target="RFC6020" format="default"/>
            .
            This document defines only the algorithm for comparing the compiled
            schema. The output of this algorithm can be utilized by tools
            processing YANG instance data to determine what exact changes
            should they expect and even how to transform instance data valid for
            an old revision of a YANG module to be valid for a newer revision
            of the same YANG module. Such tools are typically clients or
            servers of YANG-driven protocols, e.g.
            NETCONF, RESTCONF, or gNMI.
        </t>
        <t>
            In addition, the comparison algorithm can assist YANG module authors
            with updating their modules and be used to
            verify the semantic version of the new revision of the YANG module
            based on the
            <xref target="I-D.ietf-netmod-yang-semver" format="default"/>
            document.</t>
    </section>
    <section anchor="terminology" numbered="true" toc="default">
      <name>Terminology and Conventions</name>
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in BCP 14
   <xref target="RFC2119" format="default"/> <xref target="RFC8174" format="default"/> when, and only when, they
   appear in all capitals, as shown here.</t>
    <t>This document makes use of the following terminology introduced in
      the YANG 1.1 Data Modeling Language <xref target="RFC7950"/>: <list
          style="symbols">
          <t>schema node</t>
        </list>
    </t>
    <t>This document uses terminology introduced in the YANG versioning
   requirements document <xref target="I-D.ietf-netmod-yang-versioning-reqs" format="default"/>.</t>
      <t>This document makes of the following terminology introduced in the
   YANG Packages <xref target="I-D.ietf-netmod-yang-packages" format="default"/>:
      </t>
      <ul spacing="normal">
        <li>YANG schema</li>
      </ul>
      <t>In addition, this document defines the terminology:
      </t>
      <ul spacing="normal">
        <li>Change scope: Whether a change between two revisions is classified as
        non-backwards-compatible or backwards-compatible.</li>
        <li>Node compatibility statement: An extension statements (e.g. nbc-change-at)
        that can be used to indicate the backwards compatibility of individual schema nodes and specific YANG statements.</li>
      </ul>
    </section>
    <section anchor="compiled_schema" numbered="true" toc="default">
      <name>Compiled YANG schema tree</name>
      <t>
          The compiled schema tree resolves all the statements used for
          syntactic abstraction and simplification to
          obtain one schema node tree with only data definition statements.
          Textual fields are kept as well because they may
          affect backwards compatibility of the whole YANG module.
      </t>
      <t>The steps taken when compiling a schema:</t>
      <ul spacing="normal">
          <li>
              'Import' statements are resolved by finding the referenced
              YANG modules and making their contents available.
          </li>
          <li>
              All submodules of a single module are merged to create one
              large YANG module.
          </li>
          <li>
              'Uses' statements are replaced by the referenced 'groupings'
              and the YANG nodes they define.
          </li>
          <li>
              'Types' referencing any 'typedef' statements are replaced
              with the actual type details.
          </li>
          <li>
              'Augments' are resolved by placing the included YANG nodes
              in their targets.
          </li>
          <li>
              'Deviation' and 'refine' statements are applied by changing
              the appropriate schema nodes.
          </li>
          <li>
              All the 'if-feature' statements are evaluated based on the
              enabled 'features' of implemented YANG modules
              and the disabled schema nodes are removed.
          </li>
        </ul>
      <t>
          After the compilation the result is still a valid YANG module
          without the following statements:
      </t>
      <ul spacing="normal">
          <li>import</li>
          <li>include</li>
          <li>revision</li>
          <li>typedef</li>
          <li>grouping</li>
          <li>augment</li>
          <li>deviation</li>
          <li>feature</li>
          <li>if-feature</li>
          <li>refine</li>
          <li>extension</li>
      </ul>
    </section>
    <section anchor="generic_comparison_algorithm" numbered="true" toc="default">
        <name>Compiled YANG schema tree comparison algorithm</name>
        <t>
            This algorithm is defined for separate compiled YANG modules. It
            first compares all the non data-definition
            statements in the module and then all the data-definition statements
            recursively. These schema-only statements are
            skipped:
        </t>
        <ul spacing="normal">
            <li>choice</li>
            <li>case</li>
        </ul>
        <t>
            The non data-definition statements are considered modified when
            their content is changed or any of their substatements are changed.
            If a statement is present in the old revision of a module and
            missing in the new revision, it is considered removed. Vice-versa,
            if missing in the old revision but present in the new revision,
            it is considered added.
        </t>
        <t>
            Data-definition statements are compared similarly except that a
            change in a descendant data-definition
            statement is not considered a change of the parent data-definition
            statement but a separate change instead.
        </t>
        <t>
            Only statements with any changes are reported and included in the
            algorithm output.
        </t>

        <section anchor="module_identification" numbered="true" toc="default">
            <name>Module identification</name>
            <t>
                When generating the comparison output of two compiled YANG
                modules, it includes unique identification of the
                modules in question. For both the old and the new revision
                of the module, its name, revision, list of submodules,
                and a leaf-list of enabled features is included. In
                addition, the same information is reported for all the
                imported YANG modules, recursively. This ensures that if
                any other output is produced with a different set of
                changes for two YANG modules, their identification information
                must also differ.
            </t>
      </section>
      <section anchor="change_content" numbered="true" toc="default">
          <name>Change content</name>
          <t>
              Non-data-definition statements are uniquely identified with
              their YANG identifier and data-definition statements
              with their absolute schema data node-ids.
          </t>
          <t>
              For every change, the changed statement and the parent of the
              changed statement are included. While
              redundant in many cases, it allows to uniquely report changes in
              nested statements, e.g. an extension instance change in the
              type of a leaf statement. Also, all the substatements with their
              value or content are included for every changed statement, for
              both older and newer revision of the YANG module, if applicable.
              This ensures that the output includes all the possibly required
              information without relying on learning it from the YANG modules
              themselves.
          </t>
      </section>
      <section anchor="change_conformance" numbered="true" toc="default">
          <name>Change conformance</name>
          <t>
              Every change is classified as either backwards-compatible or
              non-backwards-compatible based on sections 3.1.1 and 3.1.2 in
              <xref target="I-D.ietf-netmod-yang-module-versioning"
              format="default"/>.  But, there are cases when it is impossible
              for tooling to determine whether a change is backwards-compatible
              or not. The affected statements are:
          </t>
          <ul spacing="normal">
              <li>pattern</li>
              <li>when</li>
              <li>must</li>
              <li>description</li>
              <li>extension instance</li>
          </ul>
          <t>
              Normally, any change in these statement is reported as
              non-backwards-compatible. However, if the author
              of the new revision of a YANG module determines that the change of
              an aforementioned statement is backwards-compatible based on
              the compatibility rules for the specific statement, they can decide
              to use the 'schema-cmp:backwards-compatible' extension to
              signify this fact. Then, this change must be reported as
              backwards-compatible.
          </t>
      </section>
    </section>
    <section anchor="comparison_tooling" numbered="true" toc="default">
        <name>Comparison tooling</name>
        <t>
            The `yanglint` tool from the libyang library is able to generate the
            `ietf-schema-comparison` YANG data of two revisions of a YANG
            module.
        </t>
    </section>
    <section anchor="yang_modules" numbered="true" toc="default">
        <name>Schema Comparison YANG Module</name>
        <t keepWithNext="true">
            YANG module with nodes describing the differences between two
            revisions of compiled YANG modules. The "ietf-schema-comparison"
            YANG module imports definitions from the "ietf-yang-types" module
            defined in <xref target="RFC6991" format="default"/> and
            "ietf-yang-library" module defined in
            <xref target="RFC8525" format="default"/>.
        </t>
        <sourcecode name="ietf-yang-schema-comparison@2025-10-13.yang" type=""
            markers="true"><![CDATA[
module ietf-yang-schema-comparison {
  yang-version 1.1;
  namespace "urn:ietf:params:xml:ns:yang:ietf-yang-schema-comparison";
  prefix schema-cmp;

  import ietf-yang-types {
    prefix yang;
    reference
      "RFC 6991: Common YANG Data types";
  }
  import ietf-yang-library {
    prefix yanglib;
    reference
      "RFC 8525: YANG Library";
  }
  import ietf-yang-structure-ext {
    prefix sx;
    reference
      "RFC 8791: YANG Data Structure Extensions";
  }

  organization
    "IETF NETMOD (Network Modeling) Working Group";

  contact
    "WG List: NETCONF WG list <mailto:netmod@ietf.org>
     WG Web:  https://datatracker.ietf.org/wg/netmod

     Author:  Michal Vaško
              <mailto:mvasko@cesnet.cz>

     Author:  Rob Wilton
              <mailto:rwilton@cisco.com>

     Author:  Per Andersson
              <mailto:per.ietf@ionio.se>";

  description
    "This YANG 1.1 module contains definitions and extensions to
     support comparison between different versions of YANG modules. The
     output of the comparison algorithm is described in this YANG module.

     Copyright (c) 2025 IETF Trust and the persons identified as
     authors of the code.  All rights reserved.

     Redistribution and use in source and binary forms, with
     or without modification, is permitted pursuant to, and
     subject to the license terms contained in, the Revised
     BSD License set forth in Section 4.c of the IETF Trust's
     Legal Provisions Relating to IETF Documents
     (https://trustee.ietf.org/license-info).

     This version of this YANG module is part of RFC XXXX
     (https://www.rfc-editor.org/info/rfcXXXX); see the RFC
     itself for full legal notices.

     The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL',
     'SHALL NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED',
     'NOT RECOMMENDED', 'MAY', and 'OPTIONAL' in this document
     are to be interpreted as described in BCP 14 (RFC 2119)
     (RFC 8174) when, and only when, they appear in all
     capitals, as shown here.";
  // RFC Ed.: update the date below with the date of RFC publication
  // and remove this note.
  // RFC Ed.: replace XXXX (inc above) with actual RFC number and
  // remove this note.

  revision 2025-10-13 {
    description
      "Initial revision.";
    reference
      "RFC XXXX: YANG Schema Comparison";
  }

  extension backwards-compatible {
    description
      "Marks statements in a new revision of a module
       that were changed but in a backwards-compatible
       manner according to YANG 1.1 and 1.0 rules for
       updating a module.

       When used as a substatement of a 'pattern'
       statement, it means its allowed value space has
       been expanded.

       When used as a substatement of a 'when' or
       'must' statement, it means their constraint has
       been relaxed.

       When used as a substatement of a 'description'
       statement, it means it has been changed in a
       backwards-compatible way.

       When used as a substatement of an extension
       instance, it means adding, modifying, or removing
       it is a backwards-compatible change.

       Not allowed to be instiantiated for any other
       statements.";
    reference
      "RFC 7950: The YANG 1.1 Data Modeling Language, section 11;
       RFC 6020: YANG - A Data Modeling Language for the Network
       Configuration Protocol (NETCONF), section 10";
  }

  typedef data-path {
    type string;
    description
      "Used for any data paths and XPath expressions in the compared YANG
       modules. A generic type is used to not enforce their evaluation or
       validation in this context.";
  }

  typedef stmt-type {
    type enumeration {
      enum "base" {
        description
          "YANG statement 'base'.";
      }
      enum "bit" {
        description
          "YANG statement 'bit'.";
      }
      enum "config" {
        description
          "YANG statement 'config'.";
      }
      enum "contact" {
        description
          "YANG statement 'contact'.";
      }
      enum "default" {
        description
          "YANG statement 'default'.";
      }
      enum "description" {
        description
          "YANG statement 'description'.";
      }
      enum "enum" {
        description
          "YANG statement 'enum'.";
      }
      enum "error-app-tag" {
        description
          "YANG statement 'error-app-tag'.";
      }
      enum "error-message" {
        description
          "YANG statement 'error-message'.";
      }
      enum "extension-instance" {
        description
          "Any extension instance YANG statement.";
      }
      enum "fraction-digits" {
        description
          "YANG statement 'fraction-digits'.";
      }
      enum "identity" {
        description
          "YANG statement 'identity'.";
      }
      enum "length" {
        description
          "YANG statement 'length'.";
      }
      enum "mandatory" {
        description
          "YANG statement 'mandatory'.";
      }
      enum "max-elements" {
        description
          "YANG statement 'max-elements'.";
      }
      enum "min-elements" {
        description
          "YANG statement 'min-elements'.";
      }
      enum "must" {
        description
          "YANG statement 'must'.";
      }
      enum "node" {
        description
          "YANG statement 'container', 'leaf', 'leaf-list', 'list', 'anydata',
           'anyxml', 'rpc', 'action', or 'notification'.";
      }
      enum "ordered-by" {
        description
          "YANG statement 'ordered-by'.";
      }
      enum "organization" {
        description
          "YANG statement 'organization'.";
      }
      enum "path" {
        description
          "YANG statement 'path'.";
      }
      enum "pattern" {
        description
          "YANG statement 'pattern'.";
      }
      enum "presence" {
        description
          "YANG statement 'presence'.";
      }
      enum "range" {
        description
          "YANG statement 'range'.";
      }
      enum "reference" {
        description
          "YANG statement 'reference'.";
      }
      enum "require-instance" {
        description
          "YANG statement 'require-instance'.";
      }
      enum "status" {
        description
          "YANG statement 'status'.";
      }
      enum "type" {
        description
          "YANG statement 'type'.";
      }
      enum "units" {
        description
          "YANG statement 'units'.";
      }
      enum "unique" {
        description
          "YANG statement 'unique'.";
      }
      enum "when" {
        description
          "YANG statement 'when'.";
      }
    }
    description
      "Type of the statement that a change affects.";
  }

  typedef revision-or-empty {
    type union {
      type empty;
      type yanglib:revision-identifier;
    }
    description
      "Module or submodule revision. If it has none, an empty value is
       used.";
  }

  grouping ext-instance-changes {
    description
      "Describes an extension-instance statement change.";
    leaf module {
      type yang:yang-identifier;
      mandatory true;
      description
        "Module with the extension definition of an extension instance.";
    }
    leaf name {
      type yang:yang-identifier;
      mandatory true;
      description
        "Name of the extension defition of an extension instance.";
    }
    leaf argument {
      type string;
      description
        "Argument used of an extension definition.";
    }
    anydata substatements {
      description
        "Any substatements of the extension instance.";
    }
  }

  grouping status-changes {
    description
      "Describes a status statement change.";
    leaf status {
      type enumeration {
        enum "current" {
          description
            "Current effective status of a statement.";
        }
        enum "deprecated" {
          description
            "Deprecated effective status of a statement.";
        }
        enum "obsolete" {
          description
            "Obsolete effective status of a statement.";
        }
      }
      mandatory true;
      description
        "Status substatement value.";
    }
  }

  grouping must-changes {
    description
      "Describes a must statement change.";
    leaf condition {
      type data-path;
      description
        "Condition substatement value.";
    }
    leaf description {
      type string;
      description
        "Description substatement value.";
    }
    leaf reference {
      type string;
      description
        "Reference substatement value.";
    }
    leaf error-message {
      type string;
      description
        "Error-message substatement value.";
    }
    leaf error-app-tag {
      type string;
      description
        "Error-app-tag substatement value.";
    }
    list ext-instance {
      description
        "List of extension-instance substatements.";
      uses ext-instance-changes;
    }
  }

  grouping when-changes {
    description
      "Describes a when statement change.";
    leaf condition {
      type data-path;
      description
        "Condition substatement value.";
    }
    leaf description {
      type string;
      description
        "Description substatement value.";
    }
    leaf reference {
      type string;
      description
        "Reference substatement value.";
    }
    uses status-changes;
    list ext-instance {
      description
        "List of extension-instance substatements.";
      uses ext-instance-changes;
    }
  }

  grouping restriction-substmts {
    description
      "Common substatements shared by all restriction statements.";
    leaf description {
      type string;
      description
        "Description substatement value.";
    }
    leaf reference {
      type string;
      description
        "Reference substatement value.";
    }
    leaf error-message {
      type string;
      description
        "Error-message substatement value.";
    }
    leaf error-app-tag {
      type string;
      description
        "Error-app-tag substatement value.";
    }
    list ext-instance {
      description
        "List of extension-instance substatements.";
      uses ext-instance-changes;
    }
  }

  grouping type-changes {
    description
      "Describes a type statement change.";
    leaf base-type {
      type enumeration {
        enum "int8" {
          description
            "YANG built-in type 'int8'.";
        }
        enum "int16" {
          description
            "YANG built-in type 'int16'.";
        }
        enum "int32" {
          description
            "YANG built-in type 'int32'.";
        }
        enum "int64" {
          description
            "YANG built-in type 'int64'.";
        }
        enum "uint8" {
          description
            "YANG built-in type 'uint8'.";
        }
        enum "uint16" {
          description
            "YANG built-in type 'uint16'.";
        }
        enum "uint32" {
          description
            "YANG built-in type 'uint32'.";
        }
        enum "uint64" {
          description
            "YANG built-in type 'uint64'.";
        }
        enum "decimal64" {
          description
            "YANG built-in type 'decimal64'.";
        }
        enum "string" {
          description
            "YANG built-in type 'string'.";
        }
        enum "boolean" {
          description
            "YANG built-in type 'boolean'.";
        }
        enum "enumeration" {
          description
            "YANG built-in type 'enumeration'.";
        }
        enum "bits" {
          description
            "YANG built-in type 'bits'.";
        }
        enum "binary" {
          description
            "YANG built-in type 'binary'.";
        }
        enum "leafref" {
          description
            "YANG built-in type 'leafref'.";
        }
        enum "identityref" {
          description
            "YANG built-in type 'identityref'.";
        }
        enum "empty" {
          description
            "YANG built-in type 'empty'.";
        }
        enum "union" {
          description
            "YANG built-in type 'union'.";
        }
        enum "instance-identifier" {
          description
            "YANG built-in type 'instance-identifier'.";
        }
      }
      description
        "Type substatement value.";
    }
    container range {
      description
        "Range statement substatements.";
      list interval {
        description
          "Intervals of a range statement.";
        leaf min {
          type int64;
          description
            "Lower boundary of an interval of a range statement.";
        }
        leaf max {
          type int64;
          description
            "Upper boundary of an interval of a range statement.";
        }
      }
      uses restriction-substmts;
    }
    container length {
      description
        "Length statement substatements.";
      list interval {
        description
          "Intervals of a length statement.";
        leaf min {
          type uint64;
          description
            "Lower boundary of an interval of a length statement.";
        }
        leaf max {
          type uint64;
          description
            "Upper boundary of an interval of a length statement.";
        }
      }
      uses restriction-substmts;
    }
    leaf fraction-digits {
      type uint8;
      description
        "Fraction-digits substatement value.";
    }
    list pattern {
      description
        "List of pattern statements.";
      leaf expression {
        type string;
        description
          "Pattern substatement value.";
      }
      leaf inverted {
        type boolean;
        description
          "Inverted substatement value.";
      }
      uses restriction-substmts;
    }
    list enum {
      key "name";
      ordered-by user;
      description
        "List of enum statements. Keeps the same order of the statements as in
         the module.";
      leaf name {
        type yang:yang-identifier;
        description
          "Enum statement name.";
      }
      leaf description {
        type string;
        description
          "Description substatement value.";
      }
      leaf reference {
        type string;
        description
          "Reference substatement value.";
      }
      leaf value {
        type int32;
        description
          "Value substatement value.";
      }
      uses status-changes;
      list ext-instance {
        description
          "List of extension-instance substatements.";
        uses ext-instance-changes;
      }
    }
    list bit {
      key "name";
      ordered-by user;
      description
        "List of bit statements. Keeps the same order of the statements as in
         the module.";
      leaf name {
        type yang:yang-identifier;
        description
          "Bit statement name.";
      }
      leaf description {
        type string;
        description
          "Description substatement value.";
      }
      leaf reference {
        type string;
        description
          "Reference substatement value.";
      }
      leaf position {
        type uint32;
        description
          "Position substatement value.";
      }
      uses status-changes;
      list ext-instance {
        description
          "List of extension-sintance substatements.";
        uses ext-instance-changes;
      }
    }
    leaf path {
      type data-path;
      description
        "Path substatement value.";
    }
    leaf require-instance {
      type boolean;
      description
        "Require-instance substatement value.";
    }
    leaf-list base {
      type yang:yang-identifier;
      description
        "List of base substatement values.";
    }
    list ext-instance {
      description
        "List of extension-instance substatements.";
      uses ext-instance-changes;
    }
  }

  grouping node-changes {
    description
      "All compiled substatements of a data-definition node.";
    leaf config {
      type boolean;
      description
        "Config substatement value.";
    }
    leaf description {
      type string;
      description
        "Description substatement value.";
    }
    leaf mandatory {
      type boolean;
      description
        "Mandatory substatement value.";
    }
    list must {
      description
        "List of must substatements.";
      uses must-changes;
    }
    leaf presence {
      type boolean;
      description
        "Presence substatement existence.";
    }
    leaf reference {
      type string;
      description
        "Reference substatement value.";
    }
    uses status-changes;
    list when {
      description
        "List of when substatements.";
      uses when-changes;
    }
    container type {
      description
        "Type substatement.";
      uses type-changes;
      list union-type {
        description
          "List of a union type substatements.";
        uses type-changes;
      }
    }
    leaf units {
      type string;
      description
        "Units substatement value.";
    }
    leaf ordered-by {
      type enumeration {
        enum "system" {
          description
            "System-ordered list or leaf-list of items.";
        }
        enum "user" {
          description
            "User-ordered list or leaf-list of items.";
        }
      }
      description
        "Ordered-by substatement value.";
    }
    leaf-list default {
      type string;
      description
        "List of default substatement values.";
    }
    leaf min-elements {
      type uint32;
      description
        "Min-elements substatement value.";
    }
    leaf max-elements {
      type uint32;
      description
        "Max-elements substatement value.";
    }
    list unique {
      description
        "List of unique substatements.";
      leaf-list node {
        type yang:yang-identifier;
        description
          "List of nodes referenced by a unique substatement.";
      }
    }
    list ext-instance {
      description
        "List of extension-instance substatements.";
      uses ext-instance-changes;
    }
  }

  grouping module-changes {
    description
      "All compiled non-data-definition substatements of a module.";
    leaf organization {
      type string;
      description
        "Organization substatement value.";
    }
    leaf contact {
      type string;
      description
        "Contact substatement value.";
    }
    leaf description {
      type string;
      description
        "Description substatement value.";
    }
    leaf reference {
      type string;
      description
        "Reference substatement value.";
    }
    list identity {
      key "name";
      description
        "List of identity substatements.";
      leaf name {
        type yang:yang-identifier;
        description
          "Identity statement name.";
      }
      list ext-instance {
        description
          "List of extension-instance substatements.";
        uses ext-instance-changes;
      }
    }
    list ext-instance {
      description
        "List of extension-instance substatements.";
      uses ext-instance-changes;
    }
  }

  grouping conformance-type {
    description
      "Conformance type of a change.";
    leaf conformance {
      type enumeration {
        enum "backwards-compatible" {
          description
            "Backwards-compatible or editorial change.";
        }
        enum "non-backwards-compatible" {
          description
            "Non-backwards-compatible change.";
        }
      }
      mandatory true;
      description
        "Conformance information of a change in the compared YANG modules.";
    }
  }

  grouping change-info {
    description
      "Details of a single change.";
    list changed {
      key "stmt";
      min-elements 1;
      description
        "List of changes.";
      leaf stmt {
        type stmt-type;
        description
          "Changed statement.";
      }
      leaf parent-stmt {
        type stmt-type;
        description
          "Parent statement of the changed statement.";
      }
      leaf change {
        type enumeration {
          enum "modified" {
            description
              "Statement existed and was modified.";
          }
          enum "added" {
            description
              "Statement was added.";
          }
          enum "removed" {
            description
              "Statement was removed.";
          }
          enum "moved" {
            description
              "Statement was moved and the position affects the meaning.";
          }
        }
        mandatory true;
        description
          "Type of change of the statement.";
      }
      uses conformance-type;
    }
  }

  grouping module-params {
    description
      "Identification setails of a processed YANG module.";
    leaf module {
      type yang:yang-identifier;
      mandatory true;
      description
        "Compared module name.";
    }
    leaf revision {
      type revision-or-empty;
      mandatory true;
      description
        "Compared module revision.";
    }
    list submodule {
      key "name revision";
      leaf name {
        type yang:yang-identifier;
        mandatory true;
        description
          "Submodule name.";
      }
      leaf revision {
        type revision-or-empty;
        mandatory true;
        description
          "Submodule revision.";
      }
      description
        "Submodule of the main module.";
    }
    leaf-list enabled-feature {
      type yang:yang-identifier;
      description
        "All the enabled features of the module.";
    }
  }

  sx:structure schema-comparison {
    description
      "Schema comparison details.";
    list compiled-diff {
      description
        "Instance of a schema comparison of 2 YANG modules in different
         revisions with all their imports.";
      container source {
        description
          "Source module information.";
        uses module-params;
      }
      list source-import {
        key "module revision";
        description
          "List of source module imported modules information.";
        uses module-params;
      }
      container target {
        description
          "Target module information.";
        uses module-params;
      }
      list target-import {
        key "module revision";
        description
          "List of target module imported modules information.";
        uses module-params;
      }
      uses conformance-type;
      container module-diff {
        description
          "Information about direct module statement substatement changes.";
        uses change-info;
        container old {
          description
            "Changed statements in the older revision of the YANG module.";
          uses module-changes;
        }
        container new {
          description
            "Changed statements in the newer revision of the YANG module.";
          uses module-changes;
        }
      }
      list node-diff {
        key "node";
        ordered-by user;
        description
          "Information about data-definition (node) statement substatement
           changes. Keeps the traversed order of the nodes by the algorithm.
           It SHOULD follow the depth-first search order.";
        leaf node {
          type data-path;
          description
            "Path to the changed data-definition statement.";
        }
        leaf node-type {
          type enumeration {
            enum "container" {
              description
                "YANG statement 'container' node.";
            }
            enum "leaf" {
              description
                "YANG statement 'leaf' node.";
            }
            enum "leaf-list" {
              description
                "YANG statement 'leaf-list' node.";
            }
            enum "list" {
              description
                "YANG statement 'list' node.";
            }
            enum "anydata" {
              description
                "YANG statement 'anydata' node.";
            }
            enum "anyxml" {
              description
                "YANG statement 'anyxml' node.";
            }
            enum "rpc" {
              description
                "YANG statement 'rpc' node.";
            }
            enum "action" {
              description
                "YANG statement 'action' node.";
            }
            enum "notification" {
              description
                "YANG statement 'notification' node.";
            }
          }
          mandatory true;
          description
            "Type of the changed data-definition statement.";
        }
        leaf in-rpc-action {
          type enumeration {
            enum "input" {
              description
                "Data-definition statement is a descendant if an input
                 statement.";
            }
            enum "output" {
              description
                "Data-definition statement is a descendant if an output
                 statement.";
            }
          }
          description
            "Present if the changed data-definition statement is a descendant
             of an action or rpc statement.";
        }
        uses change-info;
        container old {
          description
            "All the node substatements in the older revision of the YANG
             module.";
          uses node-changes;
        }
        container new {
          description
            "All the node substatements in the newer revision of the YANG
             module.";
          uses node-changes;
        }
      }
    }
  }
}
]]></sourcecode>
    </section>
    <section anchor="contributor" numbered="true" toc="default">
      <name>Contributors</name>
      <t>This document grew out of the YANG module versioning design team that
  started after IETF 101.  The following individuals are (or have been) members
  of the design team and have worked on the YANG versioning project:</t>
      <ul spacing="normal">
        <li>Balazs Lengyel</li>
        <li>Benoit Claise</li>
        <li>Bo Wu</li>
        <li>Ebben Aries</li>
        <li>Jason Sterne</li>
        <li>Joe Clarke</li>
        <li>Juergen Schoenwaelder</li>
        <li>Mahesh Jethanandani</li>
        <li>Michael Wang</li>
        <li>Qin Wu</li>
        <li>Reshad Rahman</li>
        <li>Rob Wilton</li>
        <li>Jan Lindblad</li>
        <li>Per Andersson</li>
      </ul>
      <t>The ideas for a tooling based comparison of YANG module revisions was
   first described in <xref target="I-D.clacla-netmod-yang-model-update" format="default"/>.
   This document extends upon those initial ideas.</t>
    </section>
    <section anchor="security" numbered="true" toc="default">
      <name>Security Considerations</name>
      <t>This section follows the template defined in Section 3.7.1 of
        <xref target="RFC8407"/>.</t>

      <t>The YANG module specified in this document defines a schema for data
        that is designed to be used by offline tooling to generate output for
        differences in supplied YANG modules.</t>

      <t>The YANG module specified in this document MAY be accessed via network
        management protocols such as NETCONF <xref target="RFC6241"/> or
        RESTCONF <xref target="RFC8040"/>. The lowest NETCONF layer is the
        secure transport layer, and the mandatory-to-implement secure transport
        is Secure Shell (SSH) <xref target="RFC6242"/>. The lowest RESTCONF
        layer is HTTPS, and the mandatory-to-implement secure transport is TLS
        <xref target="RFC8446"/>.</t>

      <t>The Network Configuration Access Control Model (NACM)
        <xref target="RFC8341"/> provides the means to restrict access for
        particular NETCONF or RESTCONF users to a preconfigured subset of all
        available NETCONF or RESTCONF protocol operations and content.</t>

      <t>When the module is used for offline tooling there are no security
        considerations, since the user has full access to all YANG modules
        used.</t>

      <t>The structure "schema-comparison" contains all the groupings reflecting
        the changes between YANG modules. If the data of this structure is
        published in online tooling, care needs to be taken so that knowledge of
        YANG modules are not leaked.</t>

      <t>Since the module does not define any RPCs, actions, or notifications,
        the security considerations for such statements are not provided here.</t>
    </section>
    <section anchor="iana" numbered="true" toc="default">
      <name>IANA Considerations</name>
      <section anchor="xml-registry" numbered="true" toc="default">
        <name>The "IETF XML" Registry</name>
        <t>This document register one URI in the "ns" subregistry of
          the IETF XML Registry <xref target="RFC3688" format="default"/>
          maintained at <eref target="https://www.iana.org/assignments/xml-registry/xml-registry.xhtml#ns"/>.
          Following the format in <xref target="RFC3688" format="default"/>,
          the following registration is requested:</t>
        <t>
          <figure align="center">
            <artwork>
URI: urn:ietf:params:xml:ns:yang:ietf-schema-comparison
Registrant Contact: The IESG.
XML: N/A, the requested URI is an XML namespace.
            </artwork>
          </figure>
        </t>
      </section>

      <section anchor="yang-module-registrations" numbered="true" toc="default">
        <name>The "YANG Module Names" Registry</name>
        <t>This document registers one YANG module in the YANG Module Names
          registry <xref target="RFC6020" format="default"/> maintained at
          <eref target="https://www.iana.org/assignments/yang-parameters/yang-paramaters.xhtml"/>.
          Following the format defined in <xref target="RFC6020"/>, the below
          registration is requested:</t>
        <t>
          <figure align="center">
            <artwork>
Name: ietf-yang-schema-comparison
XML Namespace: urn:ietf:params:xml:ns:yang:ietf-yang-schema-comparison
Prefix: schema-cmp
Reference: RFC XXXX
            </artwork>
          </figure>
        </t>
      </section>
    </section>
  </middle>
  <back>
    <references title="Normative References">
        <?rfc include='reference.RFC.2119'?>
        <?rfc include='reference.RFC.3688'?>
        <?rfc include='reference.RFC.6020'?>
        <?rfc include='reference.RFC.6241'?>
        <?rfc include='reference.RFC.6242'?>
        <?rfc include='reference.RFC.6991'?>
        <?rfc include='reference.RFC.7950'?>
        <?rfc include='reference.RFC.8040'?>
        <?rfc include='reference.RFC.8174'?>
        <?rfc include='reference.RFC.8341'?>
        <?rfc include='reference.RFC.8407'?>
        <?rfc include='reference.RFC.8446'?>
        <?rfc include='reference.RFC.8525'?>
        <?ref include='reference.I-D.ietf-netmod-yang-solutions'?>
        <?ref include='reference.I-D.ietf-netmod-yang-versioning-reqs'?>
        <?ref include='reference.I-D.ietf-netmod-yang-packages'?>
        <?ref include='reference.I-D.ietf-netmod-yang-semver'?>
        <?ref include='reference.I-D.ietf-netmod-yang-module-versioning'?>
    </references>
    <references title="Informative References">
        <?ref include='reference.I-D.clacla-netmod-yang-model-update'?>
    </references>
  </back>
</rfc>
<!-- Local Variables: -->
<!-- fill-column:120 -->
<!-- End: -->
